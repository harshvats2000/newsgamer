export const max_score = 10;

export const baseurl = () => {
  var url;
  if (process.env.NODE_ENV === 'development') {
    url = 'http://localhost:5000';
  }

  if (process.env.NODE_ENV === 'production') {
    url = 'https://newsgamer.herokuapp.com';
  }

  return url;
};

export const content = [
  "Recently I was thinking about how much I used to use CSS and nowadays I don't. Don't get me wrong, CSS is still running under the hood and empowering the web pages and sometimes other applications' layouts as well. But how much are we involved in CSS actually these days and how much do we get our hands dirty working with it? Since there are awesome frameworks like Zurb Foundation, Bootstrap, Vuetify, Semantic UI, and many more I think the importance of understanding CSS for new developers getting into web development is slightly losing its value. And recently Tailwind is taking over the development world with its utility first approach. So I decided to write this article explaining my experience with CSS since pure vanilla CSS till advanced frameworks like Vuetify. In case you are a newcomer to the web development world you might get confused with all these tools out there named SASS/SCSS, LESS Stylus, and so many more. CSS (stands for Cascading Style Sheets) is a language (not a programming language) used for describing the presentation of a web page. In a simpler way, CSS is used for giving your web page beauty. CSS features a concept of selectors and attributes. It is pretty simple, a selector selects an element or multiple elements and applies some styles to them. There are two imaginations of how CSS works, many people think CSS selectors apply the styles to the elements and some people think it is the element that selects to use the styles of a CSS definition. But it is good to know that it is CSS that selects your elements. Preprocessors were the first step to kill vanilla CSS. You can barely see someone writing vanilla CSS in an enterprise project. The only people who are using vanilla CSS might be the students who are learning web development in the early stages. A framework might seem scary when calling it a FRAMEWORK but it is literally a pre-written CSS file that helps you move forward without writing lots of CSS codes yourself. For instance, a button might look ugly on a webpage without proper CSS customization. A framework gives you a simple way to apply a default style to your button. So this is another step that strays us further from CSS and understanding it. Using a framework might get really in the way of understanding some advanced concepts of CSS like grids or positioning and it isn't a good thing in my opinion. If you are working with new tools of web development like Vue or React you are highly likely using a component library to render your UI. I'm using Vuetify as my primary UI framework. When using these frameworks you might not even need to work with classes and most components already have a default look. See this simple box with shadows and borders built using Vuetify. In most projects, you won't even need to write a single line of CSS when using frameworks. This is an absolutely personal opinion. I think CSS is going to be something like Assembly language. Eventually, no one is going to use it directly but it is going to empower other tools, only some people with high knowledge of CSS will be on the side of making and developing higher-level tools.",
  'Over the last few days, since it became clear that Trump had Covid, pundit after pundit has, weepily, asked you and I to do something remarkable: to have empathy for a figure like Donald Trump. But should we? Has anyone really thought this through? Would it in fact be corrosive to have empathy for someone responsible for so much misery, suffering, and heartache? Or not? It’s often said that Donald Trump has no empathy, but the truth is darker still. Like narcissists of a certain kind, he has the opposite of empathy, not just its absence: malice. He perpetually bears a grudge. A brief list of people he’s dehumanized, vilified, and scapegoated includes the disabled, the sick, minorities, gay people, women, the press, “liberals,” opponents — it goes on and on. Donald Trump wishes the world the worst if it’s not subservient to his desires, which is the emotion behind his many tantrums and outbursts. If you don’t submit to him, you become an “enemy,” a “traitor,” someone who deserve only the worst. That is malice. It is the primary attitude and emotion of a malignant narcissist, and it is what defines Donald Trump’s personality type, like so many other authoritarians. If the world doesn’t revolve around them — they are very happy to see it crash and burn. Or, in Trump’s case, for a nation to fall ill with Covid, and end up with more than 200,000 dead. What should be immediately apparent, then, is that asking us to have empathy for a figure like Donald Trump immediately gives rise to a double standard. We are to feel something for a man who feels nothing for us, except to see the rest of us hateful, weak, and contemptible. But the question of empathy for the malicious goes much deeper than that. When pundits say “empathy,” they don’t really examine what they mean. They mean something like sympathy, perhaps, or casual well-wishes. To have empathy, though, is to step inside someone’s emotional center, their psyche, their soul, their mind. And that is where having empathy for a figure like Donald Trump begins to get genuinely troubling. To empathise with Donald Trump means to feel his emotions, and to sympathise with the moral logic that produces them. It means to feel all the terrible things he has said, and mean them, to an extent: that immigrants are vermin, that refugees and minorities are animals, that women are objects to be exploited, that power is a thing to be abused. It is to say that there is some kind of tolerable logic behind putting children in concentration camps, and cutting women open in them. When we “empathise” with such abuses of power, then we are also normalising and legitimating them. Or at least we run the grave risk of doing so. We are being asked to say, “hey, I understand! I get why you would feel that way!” But is it remotely normal to pretend that one “gets” why a figure like Trump would want to treat mass death with indifference or order his shock troops to beat and abduct people in the streets?',
  'One of the most difficult things to do on the web is figuring out if an element is visible or where an element is in relation to its parent element. Historically, this meant running calculations triggered by a scroll event, which can quickly become a performance liability for your app. Luckily, a better and much more performant way to do this has been introduced: the Intersection Observer. The Intersection Observer API allows for asynchronous checking of the ratio of the intersection of an element with a viewport and will only fire a callback when the predefined threshold(s) are met. This has opened up many user experiences that were difficult to implement in a performant way, such as infinite scrolling, lazy load images, or delaying animations until visible. Recently, I wanted to explore how one would go about implementing this in a react hook. I ran into many gotchas, but luckily Dan Abramov recently posted a very helpful guide to useEffect over at his blog, Overreacted, which helped me immensely in understanding these gotchas and what I needed to do to fix them. So I thought I would summarize what I learned to hopefully help you avoid the same mistakes I ran into. How Does The Intersection Observer API Work? In order to get a complete understanding of the Intersection Observer API, I would recommend that you check out the documentation found at MDN. Simply put, you need to create an Observer that will ‘observe’ a DOM node and call a callback when one or more of the thresholds are met. A threshold can be any ratio from 0 to 1 where 1 means the element is 100% in the viewport and 0 is 100% out of the viewport. By default, the threshold is set to 0. Optionally, You can pass an object as a second parameter to the IntersectionObersver constructor. This object lets you configure the observer. You can configure 3 possible properties: root, rootMargin, and threshold. We have the observer, but it’s not yet observing anything. To start it observing, you need to pass a dom node to the observe method. It can observe any number of nodes, but you can only pass in one at a time. There is already a big gotcha with this. Every time the component rerenders, useIntersect will be called, which means that the observer is going to be instantiated every time with a new IntersectionObserver. This is not the intended behavior. What we want to use is the useRef hook. The useRef hook is often used to keep track of a DOM node, so you can do imperative things with it later on (such as give it focus), but useRef can be used to keep any value across rerenders. We access the value of a ref through the current property on the ref itself. The ref itself is mutatable and that current value can be reassigned anytime, but we will always get back the same ref object with it’s most recent value on every rerender. One might ask, what is the difference between useRef and useState since both will return the current value. The biggest difference is how you update the value and what that means to the rest of the component using it. You can only update the state using the second value returned from useState where the ref’s value can be updated anytime by assigning a new value to the current property. Also, updating the value of a ref will not signal a rerender, where updating the state will.',
  'If you use React for front end development, chances are that you have heard of service workers. If you are not sure what they do, or how to configure them properly, this beginner’s guide to service workers in React should serve as a good first step in creating feature-rich, offline experiences in React. Service workers are scripts that are run by the browser. They do not have any direct relationship with the DOM. They provide many out of the box network-related features. Service workers are the foundation of building an offline experience. They enable features such as push notifications and background sync. Service workers are scripts that are run by the browser of a client. They do not have any direct relationship with the DOM. They provide many out of the box network-related features. Service workers are the foundation of building an offline experience. They enable features such as push notifications and background sync. If you develop the ability to activate and properly configure service workers in React, you can utilize endless possibilities by judiciously intercepting and managing network requests. In React, service workers are automatically added when you create your application through the create-react-app command, through SWPrecacheWebpackPlugin. Service workers ensure that the network is not a bottleneck to serve new requests. Let us look at the constituents of a service worker, and then explore how you can configure them to utilize their full potential. The loss of network is a common issue that developers face in ensuring a seamless connection. Thus, in recent times, the concept of offline applications to ensure superior user experience is gaining popularity. Service workers provide web developers with a lot of benefits. They improve the performance of your website. Caching key parts of your website only helps in making it load faster. Enhances user experience through an offline-first outlook. Even if one loses connectivity, one can continue to use the application normally. They enable notification and push APIs, which are not available through traditional web technologies. They enable you to perform background sync. You can defer certain actions until network connectivity is restored to ensure a seamless experience to the user. The lifecycle of a service worker is not linked to that of your web application. You install a service worker by registering it using JavaScript. This instructs the browser to begin installing it in the background. This is also the time when you get to cache your required assets. When the installation step is successful, the activation process starts. Once activated, the service worker is associated with any page in its scope. Unless it is invoked by an event, it will be terminated. The lifecycle of a service worker typically needs to be coded by the developer. In case of service workers in React, the life cycle management is handled by React itself, which makes the process easier for a developer to enable and use service workers.',
  "Let me start by saying I’m a big fan of Next.js. It’s an amazing framework for building React applications, especially when you need Server-Side Rendering (SSR). One day, I’ll write an article covering all the great things about this framework, but luckily a lot of people are already doing that. Instead, I’m now going to explain why I migrated one of my many side projects from Next.js to Create React App. Note: If you don’t care about the background story, scroll down and go straight to the conclusion. When you have many side projects (that don’t make you any money), it’s nice if you can host them for free. I have a Ruby on Rails project hosted on a custom domain on Heroku that’s already costing me more than 30 dollars a month, which is fine — if you have just one project or if that project is making you some money… The cool thing about building a React application with Firebase and Firestore is that you can build a full-stack application and go live without any costs (except for the custom domain name). I did that with side projects like FlowReads and MakerMove. I also made React Milkshake, a boilerplate for creating apps with this stack. For a new side project, I was going for that same approach but with Nextjs, and although that’s working nicely, there was one issue I ran into. The best place to deploy your Nextjs application is Vercel (formerly Zeit). Although you can start for free, I had to upgrade to the team plan (starting at 20 dollars a month) if I wanted to keep my current project live. With Next.js, you can choose whether you want your pages to be statically generated or server-rendered. If your page is server-rendered, it means that a serverless function is created for your page during the build. The team at Zeit just decided to limit the number of serverless functions to 12 — and my application had 14 pages. That meant I could no longer deploy this application — it would fail during the build process due to this limitation. I can understand the decision to limit the number of serverless functions on the free tier, but the most frustrating part of this is that my site was already deployed. After Zeit has added this limitation I couldn’t deploy any changes without upgrading! You might be thinking “But why are you server rendering every single page? Couldn’t you just statically serve at least a couple of pages?” That’s what Zeit also recommended and it’s exactly what I wanted. The only problem is that with my current implementation (using Redux), I can’t. Let me explain. With Next.js you can use getIntialProps (or since version 9.3 getServerSideProps and getStaticProps) inside your page components, which determines if a page should be server-rendered of statically generated (read more about that here). If you don't need any data inside your page it will be statically generated, but when you use getInitialProps inside _app.js all your pages are server-rendered. You will get this warning message when building your application: You have opted-out of Automatic Static Optimization due to getInitialProps in pages/_app. Now, when you use Redux as your state management library, you probably use next-redux-wrapper, so you don't have to implement anything complex to make your client state of the store in sync with the server, etc. At least, that’s what I did, and here’s the problem: This library calls getInitialProps on your _app.js file, so all your pages will implement server-side rendering. To be honest, my application didn’t need server rendering, because everything is behind a login screen. I basically only used Next.js because I wanted to experiment with it. I probably had more options than to just refactor my project to CRA, but I figured the hassle that can come from server-side rendering (even with Next.js) is not worth the time for a project that doesn’t even benefit from it that much. I also like to host things for free as long as I’m still in the development phase and with Next.js I’m not sure I can. If you use redux inside your Nextjs application (with next-redux-wrapper) and have more than 12 routes, you will need to upgrade to the team plan if you host your project on Zeit. If you don’t need SSR, are using redux, and also want to host it for free, you probably don’t want to go with Next.js. Also, if you want to use the SSG options of Next.js, you should not go with Redux. Otherwise, I can recommend you give Next.js a try because it’s a really good framework!",
];
