export const max_score = 10;

export const content = [
  "Recently I was thinking about how much I used to use CSS and nowadays I don't. Don't get me wrong, CSS is still running under the hood and empowering the web pages and sometimes other applications' layouts as well. But how much are we involved in CSS actually these days and how much do we get our hands dirty working with it? Since there are awesome frameworks like Zurb Foundation, Bootstrap, Vuetify, Semantic UI, and many more I think the importance of understanding CSS for new developers getting into web development is slightly losing its value. And recently Tailwind is taking over the development world with its utility first approach. So I decided to write this article explaining my experience with CSS since pure vanilla CSS till advanced frameworks like Vuetify. In case you are a newcomer to the web development world you might get confused with all these tools out there named SASS/SCSS, LESS Stylus, and so many more. CSS (stands for Cascading Style Sheets) is a language (not a programming language) used for describing the presentation of a web page. In a simpler way, CSS is used for giving your web page beauty. CSS features a concept of selectors and attributes. It is pretty simple, a selector selects an element or multiple elements and applies some styles to them. There are two imaginations of how CSS works, many people think CSS selectors apply the styles to the elements and some people think it is the element that selects to use the styles of a CSS definition. But it is good to know that it is CSS that selects your elements. Preprocessors were the first step to kill vanilla CSS. You can barely see someone writing vanilla CSS in an enterprise project. The only people who are using vanilla CSS might be the students who are learning web development in the early stages. A framework might seem scary when calling it a FRAMEWORK but it is literally a pre-written CSS file that helps you move forward without writing lots of CSS codes yourself. For instance, a button might look ugly on a webpage without proper CSS customization. A framework gives you a simple way to apply a default style to your button. So this is another step that strays us further from CSS and understanding it. Using a framework might get really in the way of understanding some advanced concepts of CSS like grids or positioning and it isn't a good thing in my opinion. If you are working with new tools of web development like Vue or React you are highly likely using a component library to render your UI. I'm using Vuetify as my primary UI framework. When using these frameworks you might not even need to work with classes and most components already have a default look. See this simple box with shadows and borders built using Vuetify. In most projects, you won't even need to write a single line of CSS when using frameworks. This is an absolutely personal opinion. I think CSS is going to be something like Assembly language. Eventually, no one is going to use it directly but it is going to empower other tools, only some people with high knowledge of CSS will be on the side of making and developing higher-level tools.",
  "Over the last few days, since it became clear that Trump had Covid, pundit after pundit has, weepily, asked you and I to do something remarkable: to have empathy for a figure like Donald Trump. But should we? Has anyone really thought this through? Would it in fact be corrosive to have empathy for someone responsible for so much misery, suffering, and heartache? Or not? It’s often said that Donald Trump has no empathy, but the truth is darker still. Like narcissists of a certain kind, he has the opposite of empathy, not just its absence: malice. He perpetually bears a grudge. A brief list of people he’s dehumanized, vilified, and scapegoated includes the disabled, the sick, minorities, gay people, women, the press, “liberals,” opponents — it goes on and on. Donald Trump wishes the world the worst if it’s not subservient to his desires, which is the emotion behind his many tantrums and outbursts. If you don’t submit to him, you become an “enemy,” a “traitor,” someone who deserve only the worst. That is malice. It is the primary attitude and emotion of a malignant narcissist, and it is what defines Donald Trump’s personality type, like so many other authoritarians. If the world doesn’t revolve around them — they are very happy to see it crash and burn. Or, in Trump’s case, for a nation to fall ill with Covid, and end up with more than 200,000 dead. What should be immediately apparent, then, is that asking us to have empathy for a figure like Donald Trump immediately gives rise to a double standard. We are to feel something for a man who feels nothing for us, except to see the rest of us hateful, weak, and contemptible. But the question of empathy for the malicious goes much deeper than that. When pundits say “empathy,” they don’t really examine what they mean. They mean something like sympathy, perhaps, or casual well-wishes. To have empathy, though, is to step inside someone’s emotional center, their psyche, their soul, their mind. And that is where having empathy for a figure like Donald Trump begins to get genuinely troubling. To empathise with Donald Trump means to feel his emotions, and to sympathise with the moral logic that produces them. It means to feel all the terrible things he has said, and mean them, to an extent: that immigrants are vermin, that refugees and minorities are animals, that women are objects to be exploited, that power is a thing to be abused. It is to say that there is some kind of tolerable logic behind putting children in concentration camps, and cutting women open in them. When we “empathise” with such abuses of power, then we are also normalising and legitimating them. Or at least we run the grave risk of doing so. We are being asked to say, “hey, I understand! I get why you would feel that way!” But is it remotely normal to pretend that one “gets” why a figure like Trump would want to treat mass death with indifference or order his shock troops to beat and abduct people in the streets?",
  "One of the most difficult things to do on the web is figuring out if an element is visible or where an element is in relation to its parent element. Historically, this meant running calculations triggered by a scroll event, which can quickly become a performance liability for your app. Luckily, a better and much more performant way to do this has been introduced: the Intersection Observer. The Intersection Observer API allows for asynchronous checking of the ratio of the intersection of an element with a viewport and will only fire a callback when the predefined threshold(s) are met. This has opened up many user experiences that were difficult to implement in a performant way, such as infinite scrolling, lazy load images, or delaying animations until visible. Recently, I wanted to explore how one would go about implementing this in a react hook. I ran into many gotchas, but luckily Dan Abramov recently posted a very helpful guide to useEffect over at his blog, Overreacted, which helped me immensely in understanding these gotchas and what I needed to do to fix them. So I thought I would summarize what I learned to hopefully help you avoid the same mistakes I ran into. How Does The Intersection Observer API Work? In order to get a complete understanding of the Intersection Observer API, I would recommend that you check out the documentation found at MDN. Simply put, you need to create an Observer that will ‘observe’ a DOM node and call a callback when one or more of the thresholds are met. A threshold can be any ratio from 0 to 1 where 1 means the element is 100% in the viewport and 0 is 100% out of the viewport. By default, the threshold is set to 0. Optionally, You can pass an object as a second parameter to the IntersectionObersver constructor. This object lets you configure the observer. You can configure 3 possible properties: root, rootMargin, and threshold. We have the observer, but it’s not yet observing anything. To start it observing, you need to pass a dom node to the observe method. It can observe any number of nodes, but you can only pass in one at a time. There is already a big gotcha with this. Every time the component rerenders, useIntersect will be called, which means that the observer is going to be instantiated every time with a new IntersectionObserver. This is not the intended behavior. What we want to use is the useRef hook. The useRef hook is often used to keep track of a DOM node, so you can do imperative things with it later on (such as give it focus), but useRef can be used to keep any value across rerenders. We access the value of a ref through the current property on the ref itself. The ref itself is mutatable and that current value can be reassigned anytime, but we will always get back the same ref object with it’s most recent value on every rerender. One might ask, what is the difference between useRef and useState since both will return the current value. The biggest difference is how you update the value and what that means to the rest of the component using it. You can only update the state using the second value returned from useState where the ref’s value can be updated anytime by assigning a new value to the current property. Also, updating the value of a ref will not signal a rerender, where updating the state will.",
];
